##Regular Expressions Denial of the Service (ReDOS): From the exploitation to the prevention
###An approach to use Unit Testing techniques to avoid denial of the service attacks.

Autors :Michael Hidalgo, Dinis Cruz
## Introduction

When it comes to Web application security, one of the recommendations to write software that is resilent to attacks is to perform input data validation. However, as Mobile applications and APIs (Application Programming Interface) proliferates, the number of untrusted sources of data goes up, and a potential attacker can take advantage of the lack of validations to compromise our applications.

Regular expressions provides a versatile mechanism to perform input data validation. Developers use them to validate email addresses, zip codes, phone numbers and many other task that are easily implemented throught them.

Unfortunately not all the Software engineers fully understand how regular expressions works in the background and by choosing a wrong regular expression pattern they can introduce a risk in the application. In this article we are going to discuss about a so called Regular Expression Denial of the service (ReDoS) vulnerability and how we can identify this problems early in the Sofware Development Life Cycle (SDLC) stages by enforcing a culture focused on Unit Testing.

## Understanding the Problem.

The OWASP Foundation (2012) defines this attack as:
>"The Regular expression Denial of Service (ReDoS) is a Denial of Service attack, that exploits the fact that most Regular Expression implementations may reach extreme situations that cause them to work very slowly (exponentially related to input size). An attacker can then cause a program using a Regular Expression to enter these extreme situations and then hang for a very long time."

Althought a broad explaination about regular expression engines is out of the scope of this article,it is important to understand that, according to Stubblebine,T (Regular Expressions Pocket Reference), a pattern matching consist of finding a section of text that is described (matched) by a regular expression. Two main rules are used to match results :

1. The earliest (leftmost) wins : The regular expression is applied to the input starting at the first character and moving toward the last. As soon as the regular expression engine finds a match,it returns.

2. Standard quantifiers are greedy : Accorting to Stubblebine, "Quantifiers specify how many times something can be repeated. The standard quantifiers attempt to match as many times as possible. The procces of giving up characters and trying less-greedy matches is called backtracking."

For this article we are focused a regular expression engine called Nondeterministic Finite Automaton (NFA).This engines usually compare each elemenent of the regex to the input string, keeping track of positions where it chose between two options in the regex. If an option fails, the engine backtracks to the most recently saved position.(Stubblebine,T 2007). It is important to note that this engine is also found in .NET, Java, Python, PHP and Ruby on rails. This article is focused on C# and therefore we are relying on The Microsoft .NET Framework System.Text.RegularExpression classes which at the heart uses NFA engines.

According to Bryan Sullivan 
>"One important side effect of backtracking is that while the regex engine can fairly quickly confirm a positive match (that is, an input string does match a given regex), confirming a negative match (the input string does not match the regex) can take quite a bit longer. In fact, the engine must confirm that none of the possible “paths” through the input string match the regex, which means that all paths have to be tested.
With a simple non-grouping regular expression, the time spent to confirm negative matches is not a huge problem."

In order to illustrate this problem, let's suppose that our application provides a HTML form and the user enters the amount of products he wants to purchase. In order to validate that the amount entered is a number, we use this regular expression **^\d+$** , which can be explained as follows :
```
1. ^ assert position at start of the string
2. \d+ match a digit [0-9].Quantifier: + Between one and unlimited times, as many times as possible, giving back as needed [greedy]
3. $ assert position at end of the string
```
Having said that a value like this one **10000** should match whereas **1000A** shouldn't. In terms of performance we can identify a significant difference in the response times of evaluating both values. 

Here we start to introduce Unit Testing techniques to validate our results. For information purposes we are using a Windows 7 Virtual Machine


```csharp
const string NumberRegEx = @"^\d+$";
[TestMethod]
public void IsNumeric() 
{
    var inputString = "10000";
    Console.WriteLine(inputString);
    Assert.IsTrue(Regex.IsMatch(inputString, NumberRegEx));
        
}
```





## References
1.Cruz,D(2013) The Email RegEx that (could had) DOSed a site.http://blog.diniscruz.com/2013/03/the-email-regex-that-could-had-dosed.html

2.Stubblebine, T(2007) Regular Expression Pocket Reference, Second Edition.

3.Hollos,S. Hollos,R (2013) Finite Automata and Regular Expressions Problems and Solutions

4.Sullivan, B (2010) Regular Expression Denial of Service Attacks and Defenses

