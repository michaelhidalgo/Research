##Regular Expressions Denial of the Service (ReDOS): From the exploitation to the prevention
###An approach to use Unit Testing techniques to avoid denial of the service attacks.

Autors :Michael Hidalgo, Dinis Cruz
## Introduction

When it comes to Web application security, one of the recommendations to write software that is resilent to attacks is to perform input data validation. However, as Mobile applications and APIs (Application Programming Interface) proliferates, the number of untrusted sources of data goes up, and a potential attacker can take advantage of the lack of validations to compromise our applications.

Regular expressions provides a versatile mechanism to perform input data validation. Developers use them to validate email addresses, zip codes, phone numbers and many other task that are easily implemented throught them.

Unfortunately not all the Software engineers fully understand how regular expressions works in the background and by choosing a wrong regular expression pattern they can introduce a risk in the application. In this article we are going to discuss about a so called Regular Expression Denial of the service (ReDoS) vulnerability and how we can identify this problems early in the Sofware Development Life Cycle (SDLC) stages by enforcing a culture focused on Unit Testing.

## Understanding the Problem.

The OWASP Foundation (2012) defines this attack as:
>"The Regular expression Denial of Service (ReDoS) is a Denial of Service attack, that exploits the fact that most Regular Expression implementations may reach extreme situations that cause them to work very slowly (exponentially related to input size). An attacker can then cause a program using a Regular Expression to enter these extreme situations and then hang for a very long time."

Althought a broad explaination about regular expression engines is out of the scope of this article,it is important to understand that, according to Stubblebine,T (Regular Expressions Pocket Reference), a pattern matching consist of finding a section of text that is described (matched) by a regular expression. Two main rules are used to match results :

1. The earliest (leftmost) wins : The regular expression is applied to the input starting at the first character and moving toward the last. As soon as the regular expression engine finds a match,it returns.

2. Standard quantifiers are greedy : Accorting to Stubblebine, "Quantifiers specify how many times something can be repeated. The standard quantifiers attempt to match as many times as possible. The procces of giving up characters and trying less-greedy matches is called backtracking."

For this article we are focused a regular expression engine called Nondeterministic Finite Automaton (NFA).This engines usually compare each elemenent of the regex to the input string, keeping track of positions where it chose between two options in the regex. If an option fails, the engine backtracks to the most recently saved position.(Stubblebine,T 2007). It is important to note that this engine is also found in .NET, Java, Python, PHP and Ruby on rails. This article is focused on C# and therefore we are relying on The Microsoft .NET Framework System.Text.RegularExpression classes which at the heart uses NFA engines.

According to Bryan Sullivan 
>"One important side effect of backtracking is that while the regex engine can fairly quickly confirm a positive match (that is, an input string does match a given regex), confirming a negative match (the input string does not match the regex) can take quite a bit longer. In fact, the engine must confirm that none of the possible “paths” through the input string match the regex, which means that all paths have to be tested.
With a simple non-grouping regular expression, the time spent to confirm negative matches is not a huge problem."

In order to illustrate the problem, let's use this regular expression (\w+\d+)+C which basically performs the following checks:

1. Between one and unlimited times, as many times as possible, giving back as needed.
2. \w+ match any word character [a-zA-Z0-9_] (+ Between one and unlimited times, as many times as possible, giving back as needed).
3. \d+ match a digit [0-9] (+ Between one and unlimited times, as many times as possible, giving back as needed)
4. Matches the character C literally (case sensitive)

So matching values are **12C**,**1232323232C**,**!!!!cD4C** and non matching values are for instance **!!!!!C*, **aaaaaaC**,**abababababC**.

The following Unit test was created to verify both cases. We are using a Windows 7 32-bit Operating System, 5.22 GB RAM. Intel(R) Core (TM) iT-3820QM CPU @2.7 GHz. We are also using 4 cores.

```csharp
const string RegExPattern = @"(\w+\d+)+C";

public void TestRegularExpression() 
{
    var validInput   = "1234567C";
    var invalidInput = "aaaaaaaC";
    Regex.IsMatch(validInput, RegExPattern).assert_Is_True();
    Regex.IsMatch(invalidInput, RegExPattern).assert_Is_False();
}

Execution time : 6 milliseconds
```

Now that we've verified that our regular expression works well, let's write a new unit test to understand the backtracking problem and the performance effects. Note that the longer the string, the longer the time the regular engine will take to resolve it. We will generate 10 random strings, starting at a length  15 characters and then we will see the execution times.

```csharp
const string RegExPattern = @"(\w+\d+)+C";
[TestMethod]
public void IsValidInput()
{
    var sw = new Stopwatch();
    Int16 maxIterations = 25;
    for (var index = 15; index < maxIterations; index++)
    {
        sw.Start();
        //Generating x random numbers using FluentSharp API
        var input = index.randomNumbers() + "!";
        Regex.IsMatch(input, RegExPattern).assert_False();
        sw.stop();
        sw.Reset();
    }
  }
```
Now let's look at the test results.

| Random String             | Character Length | Elapsed Time (ms) |
|---------------------------|:----------------:|:-----------------:|
| 360817709111694!          |        16        |        16ms       |
| 2639383945572745!         |        17        |        23ms       |
| 57994905459869261!        |        18        |        50ms       |
| 327218096525942566!       |        19        |       106ms       |
| 4700367489525396856!      |        20        |       207ms       |
| 24889747040739379138!     |        21        |       394ms       |
| 156014309536784168029!    |        22        |       795ms       |
| 8797112169446577775348!   |        23        |       1595ms      |
| 41494510101927739218368!  |        24        |       3200ms      |
| 112649159593822679584363! |        25        |       6323ms      |

By looking at this results we can understand that the execution time (total time to resolve the input text against the regular expression) goes up exponentially to the size of the input. We can also see that when we append a new character, the execution time almost duplicates. This is an important finding because shows how expensive this process is, if we do not have a correct input data validation we can introduce performance issues in our appication.

## A real-life use-case and an appeal for a unit testing approach ##

Now that we have seen the problems we can face by selecting a wrong regular expression, let's discuss about a realistic scenario where we need to validate input data throught regular expressions. We strongly believe that unit testing techniques can not only help to write quality code, we also stronly believe that there exist approaches that can be use to write code that is resilent to attacks.

A common task in Web applications consist on request an email address to the user signing in our application. From a UX (user experience perspective) complaining browsers support friendly error messages when an input, that was supposed to be an email address, does not match with the requirements in terms of format. Here is a UI validation when a input textbox (with the email type is set) and the value is not a valid email address.

![alt tag](https://github.com/michaelhidalgo/Research/blob/master/RegEx/1.png)

However relying on a UI validation is not longer enought. An eaveasdropper can easily perform an HTTP request without using a browser and sending a payload that can compromise our application. In the following use case, we are using a backend valitation for the email address by using a regular expression. We will show you the real power of regular expressions here, we are not only testing that the regular expression validates the input but also how it behaves when sending any arbitrary input.

We are using this **evil regular expression to validate the email: ^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$ ** , an here is our unit test:

```csharp
const string EmailRegex = @"^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$";
[TestMethod]
public void ValidateEmailAddress() 
{
    var validEmailAddress   = "michael.hidalgo@owasp.org";
    var invalidEmailAddress = new String[] { "a", "abc.com", "1212", "aa.bb.cc", "aabcr@s" };
    Regex.IsMatch(validEmailAddress, EmailRegex).assert_Is_True();
    //Looping throught invalid email address
    foreach (var email in invalidEmailAddress) 
    {
        Regex.IsMatch(email, EmailRegex).assert_Is_False();
    }
}
Elapsed time: 6ms.
```
### The explotation ###
So far the previous regular expression chosed to valid an email address seems to work well, we have added some unit test that verifies valid an invalid inputs. But how does it behaves when we send an arbitrary input, from a variable length, do we face a denial of the service attack? This kind of questions can be solved wit unit testing techniques and the following test allow us to identify a potential denial of the service vulnerability in our code.


## References
1.Cruz,D(2013) The Email RegEx that (could had) DOSed a site.http://blog.diniscruz.com/2013/03/the-email-regex-that-could-had-dosed.html

2.Stubblebine, T(2007) Regular Expression Pocket Reference, Second Edition.

3.Hollos,S. Hollos,R (2013) Finite Automata and Regular Expressions Problems and Solutions

4.Sullivan, B (2010) Regular Expression Denial of Service Attacks and Defenses

